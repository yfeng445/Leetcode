# Source:

Scotia Bank Summer Intern (2025)

Microsoft (2020)

# Problem Statement

You are given a string `S` of length `N` which encodes a non-negative number `V` in a binary form. Two types of operations may be performed on it to modify its value:

- If `V` is odd, subtract 1 from it.
- If `V` is even, divide it by 2.

These operations are performed until the value of `V` becomes 0.

For example, if string `S = "011100"`, its value `V` initially is 28. The value of `V` would change as follows:

- `V = 28`, which is even: divide by 2 to obtain 14.
- `V = 14`, which is even: divide by 2 to obtain 7.
- `V = 7`, which is odd: subtract 1 to obtain 6.
- `V = 6`, which is even: divide by 2 to obtain 3.
- `V = 3`, which is odd: subtract 1 to obtain 2.
- `V = 2`, which is even: divide by 2 to obtain 1.
- `V = 1`, which is odd: subtract 1 to obtain 0.

Seven operations were required to reduce the value of `V` to 0.

---

## Task

Write a function:

```java
class Solution {
    public int solution(String S);
}
```

Given a string `S` consisting of `N` characters containing a binary representation of the initial value `V`, the function should return the number of operations after which its value will become 0.

## Examples

1. **Input:** `S = "011100"`
   **Output:** `7`
   Explanation: String `S` represents the number 28, which becomes 0 after seven operations, as explained above.
2. **Input:** `S = "111"`
   **Output:** `5`
   Explanation: String `S` encodes the number `V = 7`. Its value will change over the following five operations:
   * `V = 7`, which is odd: subtract 1 to obtain 6.
   * `V = 6`, which is even: divide by 2 to obtain 3.
   * `V = 3`, which is odd: subtract 1 to obtain 2.
   * `V = 2`, which is even: divide by 2 to obtain 1.
   * `V = 1`, which is odd: subtract 1 to obtain 0.
3. **Input:** `S = "1111010101111"`
   **Output:** `22`
4. **Input:** `S` consisting of "1" repeated 400,000 times
   **Output:** `799,999`

---

## Constraints

* The string `S` is made only of the characters `'0'` and/or `'1'`.
* `N`, which is the length of string `S`, is an integer within the range `[1..1,000,000]`.
* The binary representation is big-endian, i.e., the first character of string `S` corresponds to the most significant bit.
* The binary representation may contain leading zeros.

---

# Verified Code and Explanation

## Code

<pre class="!overflow-visible"><div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950"><div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">csharp</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none py-1" aria-label="Copy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor" data-darkreader-inline-fill=""></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-csharp">public int NumOfOperationsToConvertToZero(string s)
{
    int i = s.Length - 1, numOperations = 0;
    while (i > 0)
    {
        numOperations++;
        if (s[i] == '1')
        {
            numOperations++;
        }
        i--;
    }
    if (s[i] == '1')
        numOperations++;
    return numOperations;
}
</code></div></div></pre>

## Explanation

1. Start from the least significant bit (rightmost).
2. Iterate through the binary string.
3. Increment operations count by 1 for each bit (base case).
4. Increment additional operation when encountering a '1' (subtraction case).
5. Special check for the most significant bit (leftmost) to ensure all bits are processed.

The algorithm is **optimal** with `O(N)` time complexity since it processes each bit exactly once.
